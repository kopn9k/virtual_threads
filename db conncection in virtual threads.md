# HikariCP and Spring Data JPA with Virtual Threads: Connection Management Explained

## Connection Reuse vs. New Connections per Operation  
 ([java - The HikariPC connection pooling not share connection pool between clients? - Stack Overflow](https://stackoverflow.com/questions/67656717/the-hikaripc-connection-pooling-not-share-connection-pool-between-clients)) *Illustration: A connection pool allows multiple operations (or threads/clients) to share a limited number of database connections, reusing them instead of opening a new physical connection for each request.* In our case, HikariCP manages such a pool behind Spring Data JPA. When your background virtual thread performs a database operation (e.g. calling a Spring Data repository method), it requests a connection from the pool. HikariCP will typically return an already-open connection (or open one if none are free) rather than creating a brand-new physical connection each time. Once the repository call completes, Spring (via JPA) will call `Connection.close()` on that connection – but **HikariCP intercepts this** call so that it *does not actually close the physical connection* but instead returns it to the pool for reuse ([hikaricp - JDBC connection lifecycle for Connection Pool (Hikari) reuse - Stack Overflow](https://stackoverflow.com/questions/39237850/jdbc-connection-lifecycle-for-connection-pool-hikari-reuse#:~:text=I%20don%27t%20know%20Hikari%20specifically%2C,you%20are%20done%20with%20it)). In other words, each loop iteration **borrows** a connection from the pool and then **releases** it back; the same few connections are reused over and over, avoiding the overhead of constant opens/closes.

In practical terms, HikariCP keeps a pool of connections open (by default, up to 10 connections in a Spring Boot app ([postgresql - Springboot HikariCP - Stack Overflow](https://stackoverflow.com/questions/44766968/springboot-hikaricp#:~:text=In%20springboot%2C%20you%20can%20set,application.properties))). If your infinite loop is the only database activity, you’ll likely only ever use one connection at a time. HikariCP may even *eagerly open* some connections at startup (to fill the pool), but it will not open a new database socket on every query. Instead, the already-open connection gets reused on the next iteration (since 5 seconds of sleep is well below any idle timeout, as discussed below). This means HikariCP **does not repeatedly open/close the physical database connection** for each operation – it will reuse the same connection from the pool until it needs another (or until that connection is closed or evicted due to pool policies).

**Key point:** The connection lifecycle for each operation is managed by the pool. Your code (or Spring’s code) calls `dataSource.getConnection()` to get a Connection, uses it for the query, then calls `close()` to return it. HikariCP’s pooled Connection wrapper ensures that `close()` **just returns it to the pool** instead of truly closing ([hikaricp - JDBC connection lifecycle for Connection Pool (Hikari) reuse - Stack Overflow](https://stackoverflow.com/questions/39237850/jdbc-connection-lifecycle-for-connection-pool-hikari-reuse#:~:text=I%20don%27t%20know%20Hikari%20specifically%2C,you%20are%20done%20with%20it)). Therefore, in a loop of database operations, HikariCP will *reuse an existing connection* if available, rather than incurring the cost of establishing a new TCP connection to the database on every iteration.

## Transaction Management in a Virtual Thread Context  
Spring’s transaction management works the same way on a virtual thread as it does on a platform thread – the fact that the thread is virtual is transparent to the framework. Each database operation you perform via a Spring Data JPA repository will typically run within its own transaction context. By default, **CRUD repository methods in Spring Data JPA are transactional** (read operations default to a read-only transaction) ([Transactionality :: Spring Data JPA](https://docs.spring.io/spring-data/jpa/reference/jpa/transactions.html#:~:text=By%20default%2C%20methods%20inherited%20from,from%20the%20actual%20fragment%20method)). This means that when you call, for example, `myRepository.findAll()` inside your loop, Spring will begin a new transaction, execute the query, then commit (or roll back on error) that transaction when the method returns. The transaction boundary ensures the associated Hibernate `Session/EntityManager` and JDBC Connection are closed and returned to the pool at the end of each call.

Virtual threads do not change this behavior. Spring uses a thread-bound transaction context (typically a `ThreadLocal` to bind the transaction). A virtual thread is still a distinct `Thread` instance, so it has its own transaction scope. Each iteration of your loop invokes the repository method on the Spring bean proxy, which triggers transaction interception as usual. The net effect is that **each loop iteration runs as a separate transaction**, with the database connection acquired at the start and released at the end of that iteration. Spring’s `@Transactional` infrastructure will have full effect inside the virtual thread. There’s nothing special you need to do for transactions – they will work as expected. For example, if `findAll()` is annotated with `@Transactional(readOnly=true)` by Spring Data (which it is by default for repository find operations ([Transactionality :: Spring Data JPA](https://docs.spring.io/spring-data/jpa/reference/jpa/transactions.html#:~:text=By%20default%2C%20methods%20inherited%20from,from%20the%20actual%20fragment%20method))), that annotation is honored and a read-only transaction is started on the virtual thread for that call.

One thing to keep in mind is that transaction scope does **not** propagate from your main thread to the background thread. If you launch the virtual thread inside a method that is transactional, that transaction **will not be active** in the new thread (Spring does not propagate transactions across threads). In your scenario this likely isn’t an issue, since you’re starting the loop on application startup and not trying to share a transaction. But it means that if you wanted multiple repository calls in the *same* iteration of the loop to share a transaction, you would need to handle that within the thread itself (e.g. call a service method annotated with `@Transactional` that encapsulates those calls). In most cases, though, treating each iteration as its own transaction is preferable for a long-running loop – it ensures each cycle’s work is committed and the connection is freed before the thread sleeps.

**Summary:** Spring’s transaction management **does apply** in the virtual thread. Each repository call will start and end a transaction normally. The virtual thread’s database operation will be enclosed in a transaction just as it would on any other thread. There’s no special configuration needed for transactions in a virtual thread context, and the use of `@Transactional` (either explicitly on your methods or implicitly on repository methods) is effective in controlling the scope of work and connection lifecycle for each DB operation.

## Idle Connections and HikariCP’s Cleanup Mechanisms  
After each iteration of your loop, once the transaction is committed and the repository method returns, the JDBC connection is returned to the HikariCP pool. That connection then becomes **idle** (sitting in the pool unused) until the next iteration wakes up 5 seconds later and borrows it again. HikariCP has built-in rules for how long to keep idle connections around and how to handle connections that might be left hanging. In your scenario, because the thread is running continuously with only a short sleep, the connection will almost always be reused before any idle timeout kicks in. By default, HikariCP’s `idleTimeout` is 600,000 ms (10 minutes) ([GitHub - brettwooldridge/HikariCP: 光 HikariCP・A solid, high-performance, JDBC connection pool at last.](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%20600000%20%2810)). This means if a connection has been sitting in the pool unused for 10 minutes, and if the pool has more connections than the configured minimum idle, Hikari will close that idle connection to shrink the pool. In your case, the interval is 5 seconds, so the connection never stays idle long enough to be closed for idleness. HikariCP will happily keep that connection open and ready. 

It’s worth noting that by default Spring Boot configures HikariCP with `minimumIdle` equal to `maximumPoolSize` (which is 10 by default) ([GitHub - brettwooldridge/HikariCP: 光 HikariCP・A solid, high-performance, JDBC connection pool at last.](https://github.com/brettwooldridge/HikariCP#:~:text=,Default%3A%2010)). This effectively keeps the pool “full” of connections. So even if one connection is idle, HikariCP won’t drop it unless it’s above the pool size (which it won’t be) or the `minimumIdle` is lowered. In short, HikariCP will **keep the connection open and reuse it** every 5 seconds, rather than opening a new one. Only if your loop stopped using the database for a prolonged period (exceeding the idle timeout) would Hikari consider closing that connection. And even then, Hikari would keep at least `minimumIdle` connections alive (by default, 10) ([GitHub - brettwooldridge/HikariCP: 光 HikariCP・A solid, high-performance, JDBC connection pool at last.](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%20600000%20%2810)). So in a typical configuration, the connection stays open indefinitely, periodically doing work, and that’s fine.

HikariCP also handles cases of *broken or stale connections*. For example, if the database server closes the connection (perhaps due to a network hiccup or a database restart), HikariCP will detect this when you try to use the connection and will discard that connection and open a new one. HikariCP employs an optional health check (`Connection.isValid()` or a test query) each time a connection is taken from the pool (or at a regular keep-alive interval) to ensure the connection is alive. Additionally, Hikari’s `maxLifetime` setting (default 30 minutes) ensures that no single physical connection is used beyond a certain time – once a connection ages past this lifetime, Hikari will retire it after it’s returned to the pool, potentially replacing it with a new connection on the next request ([GitHub - brettwooldridge/HikariCP: 光 HikariCP・A solid, high-performance, JDBC connection pool at last.](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%201800000%20%2830%20minutes)). This helps avoid any resource leaks or degradation that can happen with very long-lived database connections. In practice, with a loop continuously using the connection, HikariCP will eventually retire that connection after ~30 minutes (not in the middle of a transaction, but after it’s returned to the pool) and establish a fresh one, all transparently. You likely won’t notice this aside from maybe a log message at debug level. 

**Potentially leaked connections:** If your code were to **borrow a connection and never return it** (for example, due to a bug where `Connection.close()` is never called), HikariCP has a mechanism to detect this. You can enable the `leakDetectionThreshold` setting to have HikariCP log a warning if a connection has been checked out longer than a certain number of milliseconds ([GitHub - brettwooldridge/HikariCP: 光 HikariCP・A solid, high-performance, JDBC connection pool at last.](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%200)). By default this is off (`0` = disabled), but if set (minimum 2000ms), Hikari will log a message identifying a possible connection leak if a connection isn’t returned within that time ([GitHub - brettwooldridge/HikariCP: 光 HikariCP・A solid, high-performance, JDBC connection pool at last.](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%200)). In a Spring Data JPA scenario, an unchecked-out connection usually means a transaction that never completed. In your loop, since each iteration is quick and properly managed by Spring, you shouldn’t hit leak warnings in normal operation. But if, say, an iteration hung indefinitely (perhaps stuck in a slow query or deadlock) and the connection stayed checked out, Hikari would log a warning after the threshold. This is a **detection mechanism** – HikariCP won’t forcibly yank the connection back (because it can’t safely do so from a running thread), but it will alert you to the issue. 

In summary, HikariCP will manage idle connections by keeping them around for fast reuse (closing them only after long inactivity or when reducing pool size), and it has features to identify connections that are not properly closed. In a continuously running loop with frequent queries, you can expect the same one or two connections to be recycled repeatedly, with Hikari handling any low-level maintenance like evicting broken connections or rotating them after a certain lifespan.

## Connection Leak Risks and Prevention  
In the architecture you’ve described (a long-lived background thread using Spring Data JPA and HikariCP), **connection leaks are not inherently likely** if everything is set up correctly – but it’s wise to be aware of the risks and how to mitigate them. A “connection leak” means a connection was checked out from the pool and never returned, which would eventually exhaust the pool if it happened repeatedly. In a Spring Boot + JPA scenario, leaks typically only occur if you circumvent Spring’s normal transaction handling or there’s a bug/exception that breaks the normal flow.

Here are some considerations regarding leaks in this context:

- **Spring-managed connections are auto-closed:** When you use Spring Data JPA repositories or `@Transactional` service methods, Spring’s transaction manager will always close the JDBC Connection at the end of the transaction. Even if an exception occurs during the database operation, Spring will trigger a rollback and release the connection. This makes leaks under normal operations uncommon. Each iteration in your loop should begin and end a transaction, returning the Connection to HikariCP. As long as that pattern holds, you won’t leak connections.

- **What if the thread crashes or is interrupted mid-operation?** If your virtual thread were to die unexpectedly while holding a connection (say the thread is stopped or an unchecked exception bubbles up and terminates the thread), that could potentially lead to a leak because the connection might not be returned. However, if an exception is thrown during a Spring Data JPA call, typically the call would unwind through Spring’s AOP proxy which will close the EntityManager/Connection in a `finally` block. For example, if `findAll()` throws an exception, Spring’s transaction interceptor still ensures the connection is released properly. That said, if your code catches exceptions outside the Spring infrastructure and then doesn’t complete the transaction, it could cause issues. It’s a good practice to handle exceptions inside the loop so that you can log them and allow the loop to continue or exit gracefully, rather than letting the thread die without cleanup.

- **Enabling leak detection:** For peace of mind, especially in development or testing, you can enable HikariCP’s leak detection feature. For example, in *application.properties* you could set: `spring.datasource.hikari.leak-detection-threshold=5000` (milliseconds). Then if any connection is held longer than 5 seconds, HikariCP will log a message about a possible leak (with a stack trace of where it was acquired) ([postgresql - Springboot HikariCP - Stack Overflow](https://stackoverflow.com/questions/44766968/springboot-hikaricp#:~:text=connection%20in%20the%20pool%20as,returning%20to%20Hikari%20pool)). In a controlled test, your loop’s queries (which should complete well under 5s) should never trigger this. If you do see a leak warning, it indicates something is stuck – a useful signal for debugging.

- **Monitor pool usage:** It’s a good idea to monitor HikariCP’s pool metrics (e.g., the number of active vs. idle connections). Spring Boot and HikariCP integrate with metrics frameworks (Micrometer, etc.), or you can enable debug logging for Hikari. If you notice that over time the number of active connections only grows and never comes back down to idle, that’s a sign of a leak. Under normal operation in your scenario, you’d expect at most 1 active connection at a time (during a DB call), which then returns to idle. If, for example, you saw 2 active connections stuck and your loop is single-threaded, that would mean one connection was never returned and a second had to be taken for a new operation – a leak situation.

- **Keep transactions short:** This is more of a best practice (discussed more below), but it also relates to leak prevention. Avoid any design where the thread holds a database transaction open for an extended period (especially while doing non-database work or sleeping). Not only can that appear like a “leak” to the detection (if it exceeds the threshold), but it can also lead to other problems like locking. In your setup, each iteration commits quickly, which is good.

In summary, connection leaks *shouldn’t* be a major risk in this architecture provided you use Spring’s data access patterns correctly. Spring and HikariCP handle the acquisition and release of connections for you. The main cause of leaks would be if you circumvented that (e.g., manually grabbing a Connection and forgetting to close it) or an unforeseen error scenario. Mitigation strategies include using Spring’s @Transactional (so that the framework manages connections), enabling Hikari’s leak detection to catch any anomalies, and testing the loop under failure conditions to ensure connections are freed even if an iteration fails. With these in place, the risk of leaks is minimal. As one HikariCP recommendation suggests: enable leakDetectionThreshold and check the logs to see if any connection is “taking more time and not returning to Hikari pool” ([postgresql - Springboot HikariCP - Stack Overflow](https://stackoverflow.com/questions/44766968/springboot-hikaricp#:~:text=connection%20in%20the%20pool%20as,returning%20to%20Hikari%20pool)) – if you consistently see none, you’re in good shape.

## Best Practices for Long-Running DB Tasks with Virtual Threads  
Running a long-lived background task that periodically accesses the database can be a robust solution, especially with Java’s lightweight virtual threads. Here are some **best practices** to ensure reliability and efficiency in this setup:

- **Use one transaction per cycle of work:** Each iteration of your loop should open, perform, and commit/rollback its own transaction. This is already happening with Spring Data JPA repository calls. Keeping transactions scoped to a single unit of work ensures that you’re not holding database resources (locks, connections) longer than necessary. It also means if one iteration fails, it won’t affect the others – the error will roll back only that iteration’s work. If you need to perform multiple repository calls in one iteration and want them atomic, consider wrapping them in a single @Transactional service method so they commit together; otherwise, separate transactions per call are fine.

- **Don’t sleep or block while holding a connection:** Ensure that any waiting (`Thread.sleep(5000)` in your case) happens **after** the database transaction has completed and the connection is returned to the pool. For example, do **not** write a loop like `while(true) { repo.save(...); Thread.sleep(5000); }` if the `save` is annotated @Transactional on the whole method – that would keep the transaction (and connection) open during the sleep. In your code, because the repository call returns before the sleep, you’re doing it correctly. The pattern should be: *acquire connection -> do DB work -> commit/close -> release connection -> then sleep*. This avoids tying up a pooled connection doing nothing, and it avoids long transactions. In a virtual thread scenario, sleeping doesn’t block an OS thread, but it **would still hold the DB connection** if done inside the transaction, which is a limited resource. So always complete the DB operation before any long pause.

- **Leverage Spring’s scheduling or async infrastructure if appropriate:** Manually managing an infinite loop is fine, but you might also consider using Spring’s `@Scheduled` tasks for a cleaner approach to periodic execution. Spring’s scheduler can be configured to use a virtual thread executor as well, if you want the benefits of virtual threads. The advantage of using a scheduled task or an `ExecutorService` is that it integrates with Spring’s lifecycle (for example, you can ensure it shuts down on application stop). If you continue with your current approach, consider shutting down the `ExecutorService` if the application context closes, and handle `InterruptedException` in your loop (your code should already catch `InterruptedException` from `Thread.sleep` and break out of the loop gracefully, which it sounds like you’re doing or should do).

- **Proper error handling in the loop:** Since this thread is long-running, you want it to be resilient. Catch exceptions around your database operations so that a transient error (like a momentary database outage or a JDBC exception) doesn’t kill the thread outright. For example: 
  ```java
  try {
      List<Thing> results = repository.findAll();
      // process results...
  } catch (Exception e) {
      // log the error, maybe increment a metric
      // decide whether to break out or continue. Often you'd continue the loop after a delay.
  }
  ```
  If an exception occurs, Spring will have already rolled back the transaction and released the connection, so you typically can just log it and continue. You might want to add a longer sleep after an error to avoid tight looping on failures.

- **Tune HikariCP settings if needed:** For a single background thread, the default HikariCP settings are usually fine. You might be able to lower `maximumPoolSize` if you know only one connection will be used at a time (to avoid unnecessary idle connections), but if your application also serves web requests or other tasks, leave it at default or set appropriately for overall load. Be mindful of the database’s own connection limits and how many threads/tasks might hit the DB concurrently. Virtual threads allow a high level of concurrency, but your database connection pool still needs to be sized to the workload. If you ever increase the number of background tasks or use more virtual threads in parallel, adjust the pool size accordingly so threads don’t starve waiting for connections (or conversely, so you don’t overwhelm the DB with too many connections). Also, as mentioned, you can use `leakDetectionThreshold` in non-prod to catch any misuses early ([postgresql - Springboot HikariCP - Stack Overflow](https://stackoverflow.com/questions/44766968/springboot-hikaricp#:~:text=connection%20in%20the%20pool%20as,returning%20to%20Hikari%20pool)).

- **Use read-only transactions for read loops:** If your background thread is only reading data (and not modifying anything), you don’t need to do anything special – Spring Data already marks repository find operations as read-only. This can hint to Hibernate and the database that it can optimize for a read transaction (for example, avoiding unnecessary flushes or locking). If you write to the database, ensure those operations are committed promptly. In either case, keep an eye on transaction boundaries as discussed.

- **Monitor and profile:** Long-running threads can sometimes suffer from subtle issues like memory leaks (not with connections, but e.g. if you keep accumulating data in memory). In a JPA context, one thing to watch is the first-level cache of the EntityManager. Because each iteration uses a new EntityManager (new transaction), you won’t accumulate entities in the persistence context across iterations – this is good. Just be careful if you were to reuse an EntityManager or if you used something like Spring’s OpenSessionInView in a background thread (which you shouldn’t here) – that could accumulate state. It sounds like each call is independent, so you’re fine. Still, consider periodically reviewing memory usage and making sure the thread isn’t holding onto resources it shouldn’t (e.g., not storing large static collections of data, etc.). The virtual thread itself is lightweight, but what it does still matters.

- **Stay updated on Loom and driver compatibility:** As of Spring Boot 3.2+ and Java 21, Spring’s support for virtual threads is quite good, and major JDBC drivers (e.g., for Postgres, MySQL, etc.) are compatible with virtual threads. There have been reports of some edge cases (for example, very high concurrency with Loom and certain pools or drivers causing unusual errors ([java - Oh no! IO! Concurrency issues with virtual threads, HikariCP, and Spring Boot JDBC (Postgres) - Stack Overflow](https://stackoverflow.com/questions/79004793/oh-no-io-concurrency-issues-with-virtual-threads-hikaricp-and-spring-boot-jd#:~:text=2024,0)) ([java - Oh no! IO! Concurrency issues with virtual threads, HikariCP, and Spring Boot JDBC (Postgres) - Stack Overflow](https://stackoverflow.com/questions/79004793/oh-no-io-concurrency-issues-with-virtual-threads-hikaricp-and-spring-boot-jd#:~:text=2024,connection%20with%20an%20open%20transaction))), but for a single-thread loop you are unlikely to hit any such issues. Just ensure you’re using up-to-date versions of libraries. If you ever scale to many virtual threads doing DB I/O, test that scenario – virtual threads make it easier to spawn massive concurrency, but your DB and pool must still handle it. The good news is HikariCP is a proven library and the combination with Spring is widely used, so you’re starting on solid ground.

- **Graceful shutdown:** Since this thread is infinite, think about what happens on application shutdown. You should ensure the thread stops when the app stops. One way is to check `Thread.currentThread().isInterrupted()` in your loop condition (as in `while (!Thread.currentThread().isInterrupted())`) and break out if interrupted. When shutting down, you can interrupt the virtual thread (for example, if using an ExecutorService, call `executor.shutdownNow()`). Spring will typically shut down executors on context close if they’re defined as beans. If you created it manually in a @PostConstruct, you might have to handle it yourself. This prevents the thread from running forever in case of a context restart or a redeploy.

By following these practices – short, well-defined transactions, not holding connections during idle times, proper exception handling, and using Spring’s tools – you’ll have a robust long-running background task. The virtual thread will efficiently yield during waits (like sleep or I/O) without consuming heavy resources, and HikariCP will efficiently manage the database connections. Overall, this architecture (virtual threads + HikariCP + Spring Data JPA) is a modern and efficient way to handle periodic background database work. It provides the simplicity of blocking logic with the scalability of reactive approaches, all while relying on mature transaction and pooling mechanisms to handle the resource management details. Enjoy the benefits of Loom in your Spring Boot app!

**Sources:**

1. Spring Data JPA documentation – Transactionality of repository methods ([Transactionality :: Spring Data JPA](https://docs.spring.io/spring-data/jpa/reference/jpa/transactions.html#:~:text=By%20default%2C%20methods%20inherited%20from,from%20the%20actual%20fragment%20method))  
2. HikariCP documentation – Connection pooling behavior and configuration (connection reuse, max pool size, idle timeout, max lifetime, leak detection) ([hikaricp - JDBC connection lifecycle for Connection Pool (Hikari) reuse - Stack Overflow](https://stackoverflow.com/questions/39237850/jdbc-connection-lifecycle-for-connection-pool-hikari-reuse#:~:text=I%20don%27t%20know%20Hikari%20specifically%2C,you%20are%20done%20with%20it)) ([GitHub - brettwooldridge/HikariCP: 光 HikariCP・A solid, high-performance, JDBC connection pool at last.](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%20600000%20%2810)) ([GitHub - brettwooldridge/HikariCP: 光 HikariCP・A solid, high-performance, JDBC connection pool at last.](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%201800000%20%2830%20minutes)) ([GitHub - brettwooldridge/HikariCP: 光 HikariCP・A solid, high-performance, JDBC connection pool at last.](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%200))  
3. Spring Boot configuration for HikariCP – enabling leak detection and default pool sizes ([postgresql - Springboot HikariCP - Stack Overflow](https://stackoverflow.com/questions/44766968/springboot-hikaricp#:~:text=connection%20in%20the%20pool%20as,returning%20to%20Hikari%20pool))
